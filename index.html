<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no"/>
<title>Neon Skyhook — Swing Runner</title>
<meta name="theme-color" content="#0AE6FF"/>
<link rel="manifest" href="manifest.json">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<style>
  html,body{margin:0;height:100%;background:#050915;color:#D8E7FF;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #game{display:block;width:100vw;height:100vh;touch-action:none}
  .hud{position:fixed;left:0;right:0;top:0;display:flex;justify-content:space-between;align-items:center;padding:10px 14px;pointer-events:none}
  .chip{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);backdrop-filter:blur(8px);border-radius:999px;padding:8px 12px;font-weight:700;letter-spacing:.3px}
  .cta{position:fixed;left:50%;transform:translateX(-50%);bottom:calc(env(safe-area-inset-bottom) + 10px);background:rgba(10,230,255,.08);border:1px solid rgba(10,230,255,.35);color:#BFF6FF;padding:10px 14px;border-radius:12px;backdrop-filter:blur(8px);font-weight:700}
  .center{position:fixed;inset:0;display:grid;place-items:center;pointer-events:none}
  .title{font-weight:900;font-size:clamp(24px,5vw,36px);letter-spacing:.5px;background:linear-gradient(90deg,#11F0FF,#8B5CFF);-webkit-background-clip:text;background-clip:text;color:transparent;text-align:center}
  .btn{pointer-events:auto;cursor:pointer;margin-top:10px;display:inline-block;background:linear-gradient(135deg,#11F0FF,#8B5CFF);color:#001018;border:none;border-radius:12px;padding:10px 16px;font-weight:800}
  .small{font-size:12px;color:#8aa8d6;margin-top:6px}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud">
  <div class="chip" id="scoreChip">Score 0</div>
  <div class="chip" id="speedChip">Speed 0</div>
</div>
<div id="cta" class="cta">Tap & hold to latch • release to fling</div>
<div class="center" id="menu">
  <div>
    <div class="title">NEON SKYHOOK</div>
    <div class="small" style="text-align:center">Hold to grapple a node • Release to fly • Chain rings • Don’t crash</div>
    <div style="text-align:center"><button id="playBtn" class="btn">Play</button></div>
  </div>
</div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // ======= Sizes
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.round(window.innerWidth);
    const h = Math.round(window.innerHeight);
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ======= Game state
  const G = {
    running:false,
    t:0, dt:0, last:0,
    timescale:1,
    w:() => canvas.width / DPR,
    h:() => canvas.height / DPR,
    worldX:0,
    scrollBase: 240,    // px/s baseline scroll
    gravity: 2600,      // px/s^2
    player:{x:0,y:0,vx:140,vy:0,r:14,attached:false,anchor:null,ropeLen:0,alive:true},
    hooks:[], rings:[], gates:[],
    score:0, best: +localStorage.getItem('ns_best')||0,
  };

  // ======= Utils
  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
  const lerp=(a,b,t)=>a+(b-a)*t;

  function vibrate(ms){ if(navigator.vibrate) try{ navigator.vibrate(ms); }catch(_){} }

  // ======= Level generation
  function resetWorld(){
    G.hooks.length=0; G.rings.length=0; G.gates.length=0; G.worldX=0; G.score=0;
    const w=G.w(), h=G.h();
    G.player.x = w*0.28; G.player.y = h*0.5; G.player.vx = 140; G.player.vy = 0; G.player.attached=false; G.player.alive=true;
    spawnAhead(w*3);
  }

  function spawnAhead(px){
    // ensure content out to worldX + px
    const maxX = G.worldX + px;
    let lastHookX = G.hooks.length? G.hooks[G.hooks.length-1].x : 0;
    if(lastHookX < maxX){
      while(lastHookX < maxX){
        lastHookX += rand(180, 320);
        const hy = rand(G.h()*0.22, G.h()*0.66);
        G.hooks.push({x:lastHookX, y:hy});
        // rings near hook
        if(Math.random()>0.35){
          const rr = 10;
          const rx = lastHookX + rand(-50, 120);
          const ry = hy + rand(-80, 90);
          G.rings.push({x:rx, y:ry, r:rr, hit:false});
        }
        // occasional gate obstacle
        if(Math.random()>0.6){
          const gap = rand(120, 170);
          const mid = rand(G.h()*0.35, G.h()*0.65);
          const thickness = 34;
          // top bar
          G.gates.push({x:lastHookX+rand(40,90), y:0, w:thickness, h:mid-gap*0.5});
          // bottom bar
          G.gates.push({x:lastHookX+rand(110,160), y:mid+gap*0.5, w:thickness, h:G.h()-(mid+gap*0.5)});
        }
      }
    }
  }

  // ======= Input: hold to grapple nearest-ahead hook
  let holding=false;
  canvas.addEventListener('pointerdown', (e)=>{
    if(!G.running) return;
    holding = true;
    try{ canvas.setPointerCapture(e.pointerId); }catch(_){ }
    attachToNearest();
    hideCTA();
  });
  canvas.addEventListener('pointerup', (e)=>{
    holding=false;
    detach();
  });
  canvas.addEventListener('pointercancel', ()=>{ holding=false; detach(); });

  function attachToNearest(){
    const p=G.player; const ahead = p.x + 260 + G.worldX; // prefer ahead in world space
    let best=null, bestD=1e9;
    for(const h of G.hooks){
      if(h.x < p.x + G.worldX + 40) continue; // a bit ahead
      const d = dist(p.x+G.worldX, p.y, h.x, h.y);
      if(d<bestD && d<420) { best=h; bestD=d; }
    }
    if(best){
      p.attached = true; p.anchor = best; p.ropeLen = bestD;
      vibrate(15);
    }
  }
  function detach(){
    const p=G.player; if(!p.attached) return; p.attached=false; p.anchor=null; vibrate(8);
  }

  // ======= Physics & game loop
  function step(ts){
    if(!G.running){ G.last = ts; requestAnimationFrame(step); return; }
    const rawDt = Math.min(1/30, (ts - G.last) / 1000 || 0);
    G.last = ts;
    const dt = rawDt * G.timescale;
    G.dt = dt; G.t += dt;

    const p=G.player;

    // baseline forward scroll
    const targetVx = G.scrollBase + clamp(G.score*2, 0, 220); // mildly speeds up with score
    p.vx = lerp(p.vx, targetVx, 0.02);

    // gravity
    p.vy += G.gravity * dt;

    // integration
    p.x += p.vx * dt; p.y += p.vy * dt;

    // rope constraint when attached
    if(p.attached && p.anchor){
      const ax = p.anchor.x - G.worldX; // anchor in view space
      const ay = p.anchor.y;
      // convert to world for calc
      const wx = p.x + G.worldX; const wy = p.y;
      const dx = wx - p.anchor.x; const dy = wy - p.anchor.y;
      const d = Math.hypot(dx,dy) || 1;
      const diff = (d - p.ropeLen);
      const nx = dx/d, ny = dy/d;
      // project position back to circle, adjust velocity (remove radial)
      const k = diff; // positional correction
      const corr = 0.9; // stiffness
      const newWx = wx - nx * k * corr;
      const newWy = wy - ny * k * corr;
      // velocity: remove radial component
      const vRad = (p.vx*nx + p.vy*ny);
      const rvx = p.vx - vRad*nx;
      const rvy = p.vy - vRad*ny;
      p.vx = rvx; p.vy = rvy;
      // write back view coords
      p.x = newWx - G.worldX; p.y = newWy;

      // tiny boost on tight arcs
      if(Math.abs(diff)>2) { p.vx += -ny*12; p.vy += nx*12; }
    }

    // camera scroll follows player
    const camTarget = p.x - G.w()*0.32;
    G.worldX = Math.max(0, camTarget);
    spawnAhead(G.w()*2.6);

    // Collisions: bounds
    if(p.y < 12 || p.y > G.h()-12) crash();

    // Collisions: gates
    const px = p.x + G.worldX, py=p.y, pr=p.r;
    for(const g of G.gates){
      const gx=g.x, gy=g.y, gw=g.w, gh=g.h;
      // circle-rect overlap in world
      const cx = clamp(px, gx, gx+gw);
      const cy = clamp(py, gy, gy+gh);
      if((px-cx)**2 + (py-cy)**2 < pr*pr){ crash(); break; }
      // near-miss slow-mo for style
      const near = 26;
      const c2x = clamp(px, gx-near, gx+gw+near);
      const c2y = clamp(py, gy-near, gy+gh+near);
      if((px-c2x)**2 + (py-c2y)**2 < (pr+near)**2){ G.timescale = lerp(G.timescale, 0.75, 0.2); }
    }

    // Rings collect
    for(const r of G.rings){
      if(r.hit) continue;
      const d = Math.hypot(px - r.x, py - r.y);
      if(d < pr + r.r){ r.hit=true; G.score+=1; vibrate(12); }
    }

    // ease back timescale
    G.timescale = lerp(G.timescale, 1, 0.05);

    draw();
    requestAnimationFrame(step);
  }

  function crash(){
    if(!G.player.alive) return; G.player.alive=false; G.running=false; detach(); vibrate([30,40,30]);
    G.best = Math.max(G.best, G.score); localStorage.setItem('ns_best', G.best);
    showMenu(`Score ${G.score} • Best ${G.best}`, 'Restart');
  }

  // ======= Render
  function drawBG(){
    const w=canvas.width, h=canvas.height;
    const grd=ctx.createLinearGradient(0,0,0,h);
    grd.addColorStop(0,'#061228'); grd.addColorStop(1,'#080B14');
    ctx.fillStyle=grd; ctx.fillRect(0,0,w,h);

    // parallax grid
    ctx.save();
    ctx.scale(DPR,DPR);
    const gw=G.w(), gh=G.h();
    ctx.globalAlpha=0.25; ctx.strokeStyle='#0c243d'; ctx.lineWidth=1;
    const grid=60; const off=(G.worldX*0.3)%grid;
    for(let x=-off; x<gw; x+=grid){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,gh); ctx.stroke(); }
    for(let y=0; y<gh; y+=grid){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(gw,y); ctx.stroke(); }
    ctx.restore();
  }

  function glowLine(x1,y1,x2,y2,w,color){
    ctx.save(); ctx.scale(DPR,DPR); ctx.lineCap='round'; ctx.strokeStyle=color; ctx.lineWidth=w; ctx.shadowColor=color; ctx.shadowBlur=w*2.5; ctx.globalCompositeOperation='lighter';
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); ctx.restore();
  }
  function glowCircle(x,y,r,color,alpha=1){
    ctx.save(); ctx.scale(DPR,DPR); ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fillStyle=color; ctx.globalAlpha=alpha; ctx.shadowColor=color; ctx.shadowBlur=r*1.6; ctx.globalCompositeOperation='lighter';
    ctx.fill(); ctx.restore();
  }

  function draw(){
    drawBG();
    const w=G.w(), h=G.h();

    ctx.save(); ctx.scale(DPR,DPR); ctx.translate(-G.worldX, 0);

    // Hooks
    for(const hk of G.hooks){ glowCircle(hk.x, hk.y, 6, '#11F0FF', .9); }

    // Gates
    for(const g of G.gates){
      ctx.save(); ctx.shadowColor='#8B5CFF'; ctx.shadowBlur=18; ctx.fillStyle='rgba(139,92,255,.25)';
      ctx.fillRect(g.x, g.y, g.w, g.h); ctx.restore();
      glowLine(g.x, g.y, g.x, g.y+g.h, 3, '#8B5CFF');
      glowLine(g.x+g.w, g.y, g.x+g.w, g.y+g.h, 3, '#8B5CFF');
    }

    // Rings
    for(const r of G.rings){ if(r.hit) continue; glowCircle(r.x, r.y, r.r, '#00FFE5', .9); }

    // Player
    const p=G.player; glowCircle(p.x+G.worldX, p.y, p.r+2, '#B7F1FF', 1);

    // Rope
    if(p.attached && p.anchor){ glowLine(p.x+G.worldX, p.y, p.anchor.x, p.anchor.y, 3.5, '#11F0FF'); }

    ctx.restore();

    // HUD
    scoreChip.textContent = `Score ${G.score}`;
    const spd = Math.round((G.player.vx) * 3.6 / 10); // pretend units
    speedChip.textContent = `Speed ${spd}`;
  }

  // ======= UI helpers
  const menu = document.getElementById('menu');
  const playBtn = document.getElementById('playBtn');
  const cta = document.getElementById('cta');
  function showMenu(sub, btn){
    menu.querySelector('.small').textContent = sub || '';
    playBtn.textContent = btn||'Play';
    menu.style.display = 'grid';
    cta.style.opacity = 0; cta.style.pointerEvents='none';
  }
  function hideMenu(){ menu.style.display='none'; }
  function hideCTA(){ cta.style.opacity = 0; cta.style.pointerEvents='none'; }

  playBtn.addEventListener('click', ()=>{
    resetWorld(); hideMenu(); cta.style.opacity=1; cta.style.pointerEvents='auto';
    G.running=true; G.timescale=1; G.last=performance.now();
  }, {passive:true});

  // Start loop
  resetWorld();
  requestAnimationFrame(step);

  // PWA SW register (optional)
  if('serviceWorker' in navigator){ navigator.serviceWorker.register('sw.js'); }
})();
</script>
</body>
</html>
